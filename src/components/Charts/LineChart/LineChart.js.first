import * as d3 from 'd3';
import { line, tooltip } from 'britecharts';
import { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  selectTrendsTooltip,
  selectTrendsColorMap,
  selectTrendsResultsDateRangeLine,
} from '../../../reducers/trends/selectors';
import {
  selectViewIsPrintMode,
  selectViewWidth,
} from '../../../reducers/view/selectors';
import {
  selectQueryDateReceivedMax,
  selectQueryDateReceivedMin,
  selectQueryDateInterval,
  selectQueryLens,
} from '../../../reducers/query/selectors';
import { cloneDeep } from '../../../utils';
import { updateTrendsTooltip } from '../../../actions/trends';
import { hashObject } from '../../../utils';
import { isDateEqual } from '../../../utils/formatDate';
import {
  getLastLineDate,
  getTooltipTitle,
  pruneIncompleteLineInterval,
} from '../../../utils/chart';
import ErrorBlock from '../../Warnings/Error';
import './LineChart.less';

export const LineChart = () => {
  const dateRangeLine = useSelector(
    selectTrendsResultsDateRangeLine,
  );
  const trendsTooltip = useSelector(selectTrendsTooltip);
  const trendsColorMap = useSelector(selectTrendsColorMap);
  const viewWidth = useSelector(selectViewWidth);
  const viewIsPrintMode = useSelector(selectViewIsPrintMode);
  const queryDateReceivedMax = useSelector(selectQueryDateReceivedMax);
  const queryDateReceivedMin = useSelector(selectQueryDateReceivedMin);
  const queryDateInterval = useSelector(selectQueryDateInterval);
  const queryLens = useSelector(selectQueryLens);
  const dispatch = useDispatch();

  const [hasChart, setHasChart] = useState(false);

  // const dateRange = {
  //   from: queryDateReceivedMin,
  //   to: queryDateReceivedMax,
  // };

  /*const data = useMemo(() => {
    const processData = cloneDeep(trendsResultsDateRangeLine);
    return pruneIncompleteLineInterval(
      processData,
      dateRange,
      queryDateInterval,
    );
  });*/
  //const hasChart = true;
  // let hasChart;

  useEffect(() => {
    let tip = null;
    const dateRange = {
      from: queryDateReceivedMin,
      to: queryDateReceivedMax,
    };
    const data = cloneDeep(dateRangeLine);
    pruneIncompleteLineInterval(data, dateRange, queryDateInterval);

    setHasChart(
     Boolean(data.dataByTopic && data.dataByTopic[0].dates.length > 1)
    );
    //const chartID = '#line-chart';
    //const container = d3.select(chartID);

    // const tooltipUpdated = (tipEvent) => {
    //   dispatch(updateTrendsTooltip(tipEvent));
    // };

    // const chartWidth = (chartID) => {
    //   if (viewIsPrintMode) {
    //     return queryLens === 'Overview' ? 750 : 500;
    //   }
    //   const container = d3.select(chartID);
    //   return container.node().getBoundingClientRect().width;
    // };

    // const updateTooltip = (point) => {
    //   if (!isDateEqual(trendsTooltip.date, point.date)) {
    //     tooltipUpdated({
    //       date: point.date,
    //       dateRange: dateRange,
    //       interval: queryDateInterval,
    //       values: point.topics,
    //     });
    //   }
    // };

    // const updateInternalTooltip = (
    //   dataPoint,
    //   topicColorMap,
    //   dataPointXPosition,
    // ) => {
    //   tip.title(
    //     getTooltipTitle(dataPoint.date, queryDateInterval, dateRange, false),
    //   );
    //   tip.update(dataPoint, topicColorMap, dataPointXPosition);
    // };

    /* eslint max-statements: ["error", 23] */
    // const redrawChart = () => {
    //   if (!hasChart) {
    //     return;
    //   }

    //   const chartID = '#line-chart';
    //   const container = d3.select(chartID);
    //   const width = chartWidth(chartID);
    //   d3.select(chartID + ' .line-chart').remove();

    //   const lineChart = line();
    //   tip = tooltip()
    //     .shouldShowDateInTitle(false)
    //     .topicLabel('topics')
    //     .title('Complaints');

    //   const colorScheme = processData.dataByTopic.map(
    //     (obj) => trendsColorMap[obj.topic],
    //   );

    //   lineChart
    //     .margin({ left: 60, right: 10, top: 10, bottom: 40 })
    //     .initializeVerticalMarker(true)
    //     .isAnimated(true)
    //     .tooltipThreshold(1)
    //     .grid('horizontal')
    //     .aspectRatio(0.5)
    //     .width(width)
    //     .dateLabel('date')
    //     .colorSchema(colorScheme);

    //   if (queryLens === 'Overview') {
    //     lineChart
    //       .on('customMouseOver', tip.show)
    //       .on('customMouseMove', updateInternalTooltip)
    //       .on('customMouseOut', tip.hide);
    //   } else {
    //     lineChart.on('customMouseMove', updateTooltip);
    //   }

    //   container.datum(cloneDeep(processData)).call(lineChart);

    //   const tooltipContainer = d3.select(
    //     chartID + ' .metadata-group .vertical-marker-container',
    //   );
    //   tooltipContainer.datum([]).call(tip);

    //   const config = { dateRange, interval: queryDateInterval };

    //   if (queryLens !== 'Overview') {
    //     // get the last date and fire it off to redux
    //     const item = getLastLineDate(processData, config);
    //     if (!isDateEqual(trendsTooltip.date, item.date)) {
    //       tooltipUpdated(item);
    //     }
    //   }
    // };

    //redrawChart();

    return () => {
      const chartID = '#line-chart';
      const container = d3.select(chartID);
      d3.select(chartID + ' .line-chart').remove();
      container.datum([]);
    };
  }, [
    dateRangeLine,
    trendsTooltip,
    trendsColorMap,
    viewWidth,
    viewIsPrintMode,
    queryDateReceivedMax,
    queryDateReceivedMin,
    queryDateInterval,
    queryLens,
  ]);

  return hasChart ? (
    <div className="chart-wrapper">
      <p className="y-axis-label">Complaints</p>
      <div id="line-chart" />
      <p className="x-axis-label">Date received by the CFPB</p>
    </div>
  ) : (
    <ErrorBlock text="Cannot display chart. Adjust your date range or date interval." />
  );
};
